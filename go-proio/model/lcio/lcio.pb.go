// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proio/model/lcio.proto

/*
	Package lcio is a generated protocol buffer package.

	It is generated from these files:
		proio/model/lcio.proto

	It has these top-level messages:
		IntParams
		FloatParams
		StringParams
		Params
		ParticleID
		MCParticle
		SimTrackerHit
		TrackerRawData
		TrackerData
		TrackerHit
		TrackerPulse
		TrackerHitPlane
		TrackerHitZCylinder
		Track
		SimCalorimeterHit
		RawCalorimeterHit
		CalorimeterHit
		Cluster
		RecParticle
		Vertex
		Relation
*/
package lcio

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IntParams struct {
	Array []int32 `protobuf:"varint,1,rep,packed,name=array" json:"array,omitempty"`
}

func (m *IntParams) Reset()                    { *m = IntParams{} }
func (m *IntParams) String() string            { return proto.CompactTextString(m) }
func (*IntParams) ProtoMessage()               {}
func (*IntParams) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{0} }

func (m *IntParams) GetArray() []int32 {
	if m != nil {
		return m.Array
	}
	return nil
}

type FloatParams struct {
	Array []float32 `protobuf:"fixed32,1,rep,packed,name=array" json:"array,omitempty"`
}

func (m *FloatParams) Reset()                    { *m = FloatParams{} }
func (m *FloatParams) String() string            { return proto.CompactTextString(m) }
func (*FloatParams) ProtoMessage()               {}
func (*FloatParams) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{1} }

func (m *FloatParams) GetArray() []float32 {
	if m != nil {
		return m.Array
	}
	return nil
}

type StringParams struct {
	Array []string `protobuf:"bytes,1,rep,name=array" json:"array,omitempty"`
}

func (m *StringParams) Reset()                    { *m = StringParams{} }
func (m *StringParams) String() string            { return proto.CompactTextString(m) }
func (*StringParams) ProtoMessage()               {}
func (*StringParams) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{2} }

func (m *StringParams) GetArray() []string {
	if m != nil {
		return m.Array
	}
	return nil
}

type Params struct {
	Ints    map[string]*IntParams    `protobuf:"bytes,1,rep,name=ints" json:"ints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Floats  map[string]*FloatParams  `protobuf:"bytes,2,rep,name=floats" json:"floats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Strings map[string]*StringParams `protobuf:"bytes,3,rep,name=strings" json:"strings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Params) Reset()                    { *m = Params{} }
func (m *Params) String() string            { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()               {}
func (*Params) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{3} }

func (m *Params) GetInts() map[string]*IntParams {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *Params) GetFloats() map[string]*FloatParams {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *Params) GetStrings() map[string]*StringParams {
	if m != nil {
		return m.Strings
	}
	return nil
}

type ParticleID struct {
	Likelihood float32   `protobuf:"fixed32,1,opt,name=likelihood,proto3" json:"likelihood,omitempty"`
	Type       int32     `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	PDG        int32     `protobuf:"varint,3,opt,name=PDG,proto3" json:"PDG,omitempty"`
	AlgType    int32     `protobuf:"varint,4,opt,name=algType,proto3" json:"algType,omitempty"`
	Params     []float32 `protobuf:"fixed32,5,rep,packed,name=params" json:"params,omitempty"`
}

func (m *ParticleID) Reset()                    { *m = ParticleID{} }
func (m *ParticleID) String() string            { return proto.CompactTextString(m) }
func (*ParticleID) ProtoMessage()               {}
func (*ParticleID) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{4} }

func (m *ParticleID) GetLikelihood() float32 {
	if m != nil {
		return m.Likelihood
	}
	return 0
}

func (m *ParticleID) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ParticleID) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *ParticleID) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *ParticleID) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

type MCParticle struct {
	Parents   []uint64  `protobuf:"varint,1,rep,packed,name=parents" json:"parents,omitempty"`
	Children  []uint64  `protobuf:"varint,2,rep,packed,name=children" json:"children,omitempty"`
	PDG       int32     `protobuf:"varint,3,opt,name=PDG,proto3" json:"PDG,omitempty"`
	Vertex    []float64 `protobuf:"fixed64,4,rep,packed,name=vertex" json:"vertex,omitempty"`
	Time      float32   `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	P         []float64 `protobuf:"fixed64,6,rep,packed,name=p" json:"p,omitempty"`
	Mass      float64   `protobuf:"fixed64,7,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge    float32   `protobuf:"fixed32,8,opt,name=charge,proto3" json:"charge,omitempty"`
	PEndPoint []float64 `protobuf:"fixed64,9,rep,packed,name=PEndPoint" json:"PEndPoint,omitempty"`
	Spin      []float32 `protobuf:"fixed32,10,rep,packed,name=spin" json:"spin,omitempty"`
	ColorFlow []int32   `protobuf:"varint,11,rep,packed,name=colorFlow" json:"colorFlow,omitempty"`
	GenStatus int32     `protobuf:"varint,12,opt,name=genStatus,proto3" json:"genStatus,omitempty"`
	SimStatus uint32    `protobuf:"varint,13,opt,name=simStatus,proto3" json:"simStatus,omitempty"`
}

func (m *MCParticle) Reset()                    { *m = MCParticle{} }
func (m *MCParticle) String() string            { return proto.CompactTextString(m) }
func (*MCParticle) ProtoMessage()               {}
func (*MCParticle) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{5} }

func (m *MCParticle) GetParents() []uint64 {
	if m != nil {
		return m.Parents
	}
	return nil
}

func (m *MCParticle) GetChildren() []uint64 {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *MCParticle) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *MCParticle) GetVertex() []float64 {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *MCParticle) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MCParticle) GetP() []float64 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *MCParticle) GetMass() float64 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *MCParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *MCParticle) GetPEndPoint() []float64 {
	if m != nil {
		return m.PEndPoint
	}
	return nil
}

func (m *MCParticle) GetSpin() []float32 {
	if m != nil {
		return m.Spin
	}
	return nil
}

func (m *MCParticle) GetColorFlow() []int32 {
	if m != nil {
		return m.ColorFlow
	}
	return nil
}

func (m *MCParticle) GetGenStatus() int32 {
	if m != nil {
		return m.GenStatus
	}
	return 0
}

func (m *MCParticle) GetSimStatus() uint32 {
	if m != nil {
		return m.SimStatus
	}
	return 0
}

type SimTrackerHit struct {
	CellID0    int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1    int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Pos        []float64 `protobuf:"fixed64,3,rep,packed,name=pos" json:"pos,omitempty"`
	EDep       float32   `protobuf:"fixed32,4,opt,name=EDep,proto3" json:"EDep,omitempty"`
	Time       float32   `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	Mc         uint64    `protobuf:"varint,6,opt,name=mc,proto3" json:"mc,omitempty"`
	P          []float32 `protobuf:"fixed32,7,rep,packed,name=p" json:"p,omitempty"`
	PathLength float32   `protobuf:"fixed32,8,opt,name=pathLength,proto3" json:"pathLength,omitempty"`
	Quality    int32     `protobuf:"varint,9,opt,name=quality,proto3" json:"quality,omitempty"`
}

func (m *SimTrackerHit) Reset()                    { *m = SimTrackerHit{} }
func (m *SimTrackerHit) String() string            { return proto.CompactTextString(m) }
func (*SimTrackerHit) ProtoMessage()               {}
func (*SimTrackerHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{6} }

func (m *SimTrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimTrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimTrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimTrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *SimTrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimTrackerHit) GetMc() uint64 {
	if m != nil {
		return m.Mc
	}
	return 0
}

func (m *SimTrackerHit) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *SimTrackerHit) GetPathLength() float32 {
	if m != nil {
		return m.PathLength
	}
	return 0
}

func (m *SimTrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type TrackerRawData struct {
	CellID0 int32    `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32    `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    int32    `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	ADCs    []uint32 `protobuf:"varint,4,rep,packed,name=ADCs" json:"ADCs,omitempty"`
}

func (m *TrackerRawData) Reset()                    { *m = TrackerRawData{} }
func (m *TrackerRawData) String() string            { return proto.CompactTextString(m) }
func (*TrackerRawData) ProtoMessage()               {}
func (*TrackerRawData) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{7} }

func (m *TrackerRawData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerRawData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerRawData) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerRawData) GetADCs() []uint32 {
	if m != nil {
		return m.ADCs
	}
	return nil
}

type TrackerData struct {
	CellID0 int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    float32   `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	Charges []float32 `protobuf:"fixed32,4,rep,packed,name=charges" json:"charges,omitempty"`
}

func (m *TrackerData) Reset()                    { *m = TrackerData{} }
func (m *TrackerData) String() string            { return proto.CompactTextString(m) }
func (*TrackerData) ProtoMessage()               {}
func (*TrackerData) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{8} }

func (m *TrackerData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerData) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerData) GetCharges() []float32 {
	if m != nil {
		return m.Charges
	}
	return nil
}

type TrackerHit struct {
	CellID0 int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32     `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64 `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	Cov     []float64 `protobuf:"fixed64,5,rep,packed,name=cov" json:"cov,omitempty"`
	EDep    float32   `protobuf:"fixed32,6,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32   `protobuf:"fixed32,7,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32   `protobuf:"fixed32,8,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32     `protobuf:"varint,9,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []uint64  `protobuf:"varint,10,rep,packed,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHit) Reset()                    { *m = TrackerHit{} }
func (m *TrackerHit) String() string            { return proto.CompactTextString(m) }
func (*TrackerHit) ProtoMessage()               {}
func (*TrackerHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{9} }

func (m *TrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHit) GetCov() []float64 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHit) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHit) GetRawHits() []uint64 {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerPulse struct {
	CellID0 int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    float32   `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	Charge  float32   `protobuf:"fixed32,4,opt,name=charge,proto3" json:"charge,omitempty"`
	Cov     []float32 `protobuf:"fixed32,5,rep,packed,name=cov" json:"cov,omitempty"`
	Quality int32     `protobuf:"varint,6,opt,name=quality,proto3" json:"quality,omitempty"`
	TPC     uint64    `protobuf:"varint,7,opt,name=TPC,proto3" json:"TPC,omitempty"`
}

func (m *TrackerPulse) Reset()                    { *m = TrackerPulse{} }
func (m *TrackerPulse) String() string            { return proto.CompactTextString(m) }
func (*TrackerPulse) ProtoMessage()               {}
func (*TrackerPulse) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{10} }

func (m *TrackerPulse) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerPulse) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerPulse) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerPulse) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *TrackerPulse) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerPulse) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerPulse) GetTPC() uint64 {
	if m != nil {
		return m.TPC
	}
	return 0
}

type TrackerHitPlane struct {
	CellID0 int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32     `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64 `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	U       []float32 `protobuf:"fixed32,5,rep,packed,name=U" json:"U,omitempty"`
	V       []float32 `protobuf:"fixed32,6,rep,packed,name=V" json:"V,omitempty"`
	DU      float32   `protobuf:"fixed32,7,opt,name=dU,proto3" json:"dU,omitempty"`
	DV      float32   `protobuf:"fixed32,8,opt,name=dV,proto3" json:"dV,omitempty"`
	EDep    float32   `protobuf:"fixed32,9,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32   `protobuf:"fixed32,10,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32   `protobuf:"fixed32,11,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32     `protobuf:"varint,12,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []uint64  `protobuf:"varint,13,rep,packed,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHitPlane) Reset()                    { *m = TrackerHitPlane{} }
func (m *TrackerHitPlane) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitPlane) ProtoMessage()               {}
func (*TrackerHitPlane) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{11} }

func (m *TrackerHitPlane) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitPlane) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitPlane) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitPlane) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitPlane) GetU() []float32 {
	if m != nil {
		return m.U
	}
	return nil
}

func (m *TrackerHitPlane) GetV() []float32 {
	if m != nil {
		return m.V
	}
	return nil
}

func (m *TrackerHitPlane) GetDU() float32 {
	if m != nil {
		return m.DU
	}
	return 0
}

func (m *TrackerHitPlane) GetDV() float32 {
	if m != nil {
		return m.DV
	}
	return 0
}

func (m *TrackerHitPlane) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitPlane) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitPlane) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitPlane) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitPlane) GetRawHits() []uint64 {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitZCylinder struct {
	CellID0 int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32     `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64 `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	Center  []float32 `protobuf:"fixed32,5,rep,packed,name=center" json:"center,omitempty"`
	DRPhi   float32   `protobuf:"fixed32,6,opt,name=dRPhi,proto3" json:"dRPhi,omitempty"`
	DZ      float32   `protobuf:"fixed32,7,opt,name=dZ,proto3" json:"dZ,omitempty"`
	EDep    float32   `protobuf:"fixed32,8,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32   `protobuf:"fixed32,9,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32   `protobuf:"fixed32,10,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32     `protobuf:"varint,11,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []uint64  `protobuf:"varint,12,rep,packed,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHitZCylinder) Reset()                    { *m = TrackerHitZCylinder{} }
func (m *TrackerHitZCylinder) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitZCylinder) ProtoMessage()               {}
func (*TrackerHitZCylinder) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{12} }

func (m *TrackerHitZCylinder) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitZCylinder) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitZCylinder) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitZCylinder) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitZCylinder) GetCenter() []float32 {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *TrackerHitZCylinder) GetDRPhi() float32 {
	if m != nil {
		return m.DRPhi
	}
	return 0
}

func (m *TrackerHitZCylinder) GetDZ() float32 {
	if m != nil {
		return m.DZ
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitZCylinder) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitZCylinder) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitZCylinder) GetRawHits() []uint64 {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type Track struct {
	Type       int32               `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Chi2       float32             `protobuf:"fixed32,2,opt,name=chi2,proto3" json:"chi2,omitempty"`
	NDF        int32               `protobuf:"varint,3,opt,name=NDF,proto3" json:"NDF,omitempty"`
	DEdx       float32             `protobuf:"fixed32,4,opt,name=dEdx,proto3" json:"dEdx,omitempty"`
	DEdxErr    float32             `protobuf:"fixed32,5,opt,name=dEdxErr,proto3" json:"dEdxErr,omitempty"`
	Radius     float32             `protobuf:"fixed32,6,opt,name=radius,proto3" json:"radius,omitempty"`
	SubDetHits []int32             `protobuf:"varint,7,rep,packed,name=subDetHits" json:"subDetHits,omitempty"`
	States     []*Track_TrackState `protobuf:"bytes,8,rep,name=states" json:"states,omitempty"`
	Hits       []uint64            `protobuf:"varint,9,rep,packed,name=hits" json:"hits,omitempty"`
	Tracks     []uint64            `protobuf:"varint,10,rep,packed,name=tracks" json:"tracks,omitempty"`
}

func (m *Track) Reset()                    { *m = Track{} }
func (m *Track) String() string            { return proto.CompactTextString(m) }
func (*Track) ProtoMessage()               {}
func (*Track) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{13} }

func (m *Track) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Track) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Track) GetNDF() int32 {
	if m != nil {
		return m.NDF
	}
	return 0
}

func (m *Track) GetDEdx() float32 {
	if m != nil {
		return m.DEdx
	}
	return 0
}

func (m *Track) GetDEdxErr() float32 {
	if m != nil {
		return m.DEdxErr
	}
	return 0
}

func (m *Track) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Track) GetSubDetHits() []int32 {
	if m != nil {
		return m.SubDetHits
	}
	return nil
}

func (m *Track) GetStates() []*Track_TrackState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *Track) GetHits() []uint64 {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Track) GetTracks() []uint64 {
	if m != nil {
		return m.Tracks
	}
	return nil
}

type Track_TrackState struct {
	Loc   int32     `protobuf:"varint,1,opt,name=loc,proto3" json:"loc,omitempty"`
	D0    float32   `protobuf:"fixed32,2,opt,name=d0,proto3" json:"d0,omitempty"`
	Phi   float32   `protobuf:"fixed32,3,opt,name=phi,proto3" json:"phi,omitempty"`
	Omega float32   `protobuf:"fixed32,4,opt,name=omega,proto3" json:"omega,omitempty"`
	Z0    float32   `protobuf:"fixed32,5,opt,name=z0,proto3" json:"z0,omitempty"`
	TanL  float32   `protobuf:"fixed32,6,opt,name=tanL,proto3" json:"tanL,omitempty"`
	Cov   []float32 `protobuf:"fixed32,7,rep,packed,name=cov" json:"cov,omitempty"`
	Ref   []float32 `protobuf:"fixed32,8,rep,packed,name=ref" json:"ref,omitempty"`
}

func (m *Track_TrackState) Reset()                    { *m = Track_TrackState{} }
func (m *Track_TrackState) String() string            { return proto.CompactTextString(m) }
func (*Track_TrackState) ProtoMessage()               {}
func (*Track_TrackState) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{13, 0} }

func (m *Track_TrackState) GetLoc() int32 {
	if m != nil {
		return m.Loc
	}
	return 0
}

func (m *Track_TrackState) GetD0() float32 {
	if m != nil {
		return m.D0
	}
	return 0
}

func (m *Track_TrackState) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Track_TrackState) GetOmega() float32 {
	if m != nil {
		return m.Omega
	}
	return 0
}

func (m *Track_TrackState) GetZ0() float32 {
	if m != nil {
		return m.Z0
	}
	return 0
}

func (m *Track_TrackState) GetTanL() float32 {
	if m != nil {
		return m.TanL
	}
	return 0
}

func (m *Track_TrackState) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Track_TrackState) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

type SimCalorimeterHit struct {
	CellID0       int32                        `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1       int32                        `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy        float32                      `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	Pos           []float32                    `protobuf:"fixed32,4,rep,packed,name=pos" json:"pos,omitempty"`
	Contributions []*SimCalorimeterHit_Contrib `protobuf:"bytes,5,rep,name=contributions" json:"contributions,omitempty"`
}

func (m *SimCalorimeterHit) Reset()                    { *m = SimCalorimeterHit{} }
func (m *SimCalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*SimCalorimeterHit) ProtoMessage()               {}
func (*SimCalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{14} }

func (m *SimCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimCalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimCalorimeterHit) GetContributions() []*SimCalorimeterHit_Contrib {
	if m != nil {
		return m.Contributions
	}
	return nil
}

type SimCalorimeterHit_Contrib struct {
	MCParticle uint64    `protobuf:"varint,1,opt,name=MCParticle,proto3" json:"MCParticle,omitempty"`
	Energy     float32   `protobuf:"fixed32,2,opt,name=energy,proto3" json:"energy,omitempty"`
	Time       float32   `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	PDG        int32     `protobuf:"varint,4,opt,name=PDG,proto3" json:"PDG,omitempty"`
	StepPos    []float32 `protobuf:"fixed32,5,rep,packed,name=stepPos" json:"stepPos,omitempty"`
}

func (m *SimCalorimeterHit_Contrib) Reset()         { *m = SimCalorimeterHit_Contrib{} }
func (m *SimCalorimeterHit_Contrib) String() string { return proto.CompactTextString(m) }
func (*SimCalorimeterHit_Contrib) ProtoMessage()    {}
func (*SimCalorimeterHit_Contrib) Descriptor() ([]byte, []int) {
	return fileDescriptorLcio, []int{14, 0}
}

func (m *SimCalorimeterHit_Contrib) GetMCParticle() uint64 {
	if m != nil {
		return m.MCParticle
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetStepPos() []float32 {
	if m != nil {
		return m.StepPos
	}
	return nil
}

type RawCalorimeterHit struct {
	CellID0   int32 `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1   int32 `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Amplitude int32 `protobuf:"varint,3,opt,name=amplitude,proto3" json:"amplitude,omitempty"`
	TimeStamp int32 `protobuf:"varint,4,opt,name=timeStamp,proto3" json:"timeStamp,omitempty"`
}

func (m *RawCalorimeterHit) Reset()                    { *m = RawCalorimeterHit{} }
func (m *RawCalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*RawCalorimeterHit) ProtoMessage()               {}
func (*RawCalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{15} }

func (m *RawCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *RawCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *RawCalorimeterHit) GetAmplitude() int32 {
	if m != nil {
		return m.Amplitude
	}
	return 0
}

func (m *RawCalorimeterHit) GetTimeStamp() int32 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

type CalorimeterHit struct {
	CellID0   int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1   int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy    float32   `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr float32   `protobuf:"fixed32,4,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Time      float32   `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	Pos       []float32 `protobuf:"fixed32,6,rep,packed,name=pos" json:"pos,omitempty"`
	Type      int32     `protobuf:"varint,7,opt,name=type,proto3" json:"type,omitempty"`
	Raw       uint64    `protobuf:"varint,8,opt,name=raw,proto3" json:"raw,omitempty"`
}

func (m *CalorimeterHit) Reset()                    { *m = CalorimeterHit{} }
func (m *CalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*CalorimeterHit) ProtoMessage()               {}
func (*CalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{16} }

func (m *CalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *CalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *CalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *CalorimeterHit) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *CalorimeterHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *CalorimeterHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CalorimeterHit) GetRaw() uint64 {
	if m != nil {
		return m.Raw
	}
	return 0
}

type Cluster struct {
	Type       int32         `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Energy     float32       `protobuf:"fixed32,2,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr  float32       `protobuf:"fixed32,3,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Pos        []float32     `protobuf:"fixed32,4,rep,packed,name=pos" json:"pos,omitempty"`
	PosErr     []float32     `protobuf:"fixed32,5,rep,packed,name=posErr" json:"posErr,omitempty"`
	Theta      float32       `protobuf:"fixed32,6,opt,name=theta,proto3" json:"theta,omitempty"`
	Phi        float32       `protobuf:"fixed32,7,opt,name=phi,proto3" json:"phi,omitempty"`
	DirErr     []float32     `protobuf:"fixed32,8,rep,packed,name=dirErr" json:"dirErr,omitempty"`
	Shape      []float32     `protobuf:"fixed32,9,rep,packed,name=shape" json:"shape,omitempty"`
	PIDs       []*ParticleID `protobuf:"bytes,10,rep,name=PIDs" json:"PIDs,omitempty"`
	Clusters   []uint64      `protobuf:"varint,11,rep,packed,name=clusters" json:"clusters,omitempty"`
	Hits       []uint64      `protobuf:"varint,12,rep,packed,name=hits" json:"hits,omitempty"`
	Weights    []float32     `protobuf:"fixed32,13,rep,packed,name=weights" json:"weights,omitempty"`
	SubDetEnes []float32     `protobuf:"fixed32,14,rep,packed,name=subDetEnes" json:"subDetEnes,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{17} }

func (m *Cluster) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Cluster) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *Cluster) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *Cluster) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Cluster) GetPosErr() []float32 {
	if m != nil {
		return m.PosErr
	}
	return nil
}

func (m *Cluster) GetTheta() float32 {
	if m != nil {
		return m.Theta
	}
	return 0
}

func (m *Cluster) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Cluster) GetDirErr() []float32 {
	if m != nil {
		return m.DirErr
	}
	return nil
}

func (m *Cluster) GetShape() []float32 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *Cluster) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *Cluster) GetClusters() []uint64 {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *Cluster) GetHits() []uint64 {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Cluster) GetWeights() []float32 {
	if m != nil {
		return m.Weights
	}
	return nil
}

func (m *Cluster) GetSubDetEnes() []float32 {
	if m != nil {
		return m.SubDetEnes
	}
	return nil
}

type RecParticle struct {
	Type          int32         `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	P             []float32     `protobuf:"fixed32,2,rep,packed,name=p" json:"p,omitempty"`
	Energy        float32       `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	Cov           []float32     `protobuf:"fixed32,4,rep,packed,name=cov" json:"cov,omitempty"`
	Mass          float32       `protobuf:"fixed32,5,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge        float32       `protobuf:"fixed32,6,opt,name=charge,proto3" json:"charge,omitempty"`
	Ref           []float32     `protobuf:"fixed32,7,rep,packed,name=ref" json:"ref,omitempty"`
	PIDs          []*ParticleID `protobuf:"bytes,8,rep,name=PIDs" json:"PIDs,omitempty"`
	PIDUsed       int32         `protobuf:"varint,9,opt,name=PIDUsed,proto3" json:"PIDUsed,omitempty"`
	GoodnessOfPID float32       `protobuf:"fixed32,10,opt,name=goodnessOfPID,proto3" json:"goodnessOfPID,omitempty"`
	Recs          []uint64      `protobuf:"varint,11,rep,packed,name=recs" json:"recs,omitempty"`
	Tracks        []uint64      `protobuf:"varint,12,rep,packed,name=tracks" json:"tracks,omitempty"`
	Clusters      []uint64      `protobuf:"varint,13,rep,packed,name=clusters" json:"clusters,omitempty"`
	StartVtx      uint64        `protobuf:"varint,14,opt,name=startVtx,proto3" json:"startVtx,omitempty"`
}

func (m *RecParticle) Reset()                    { *m = RecParticle{} }
func (m *RecParticle) String() string            { return proto.CompactTextString(m) }
func (*RecParticle) ProtoMessage()               {}
func (*RecParticle) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{18} }

func (m *RecParticle) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RecParticle) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *RecParticle) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *RecParticle) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *RecParticle) GetMass() float32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *RecParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *RecParticle) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *RecParticle) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *RecParticle) GetPIDUsed() int32 {
	if m != nil {
		return m.PIDUsed
	}
	return 0
}

func (m *RecParticle) GetGoodnessOfPID() float32 {
	if m != nil {
		return m.GoodnessOfPID
	}
	return 0
}

func (m *RecParticle) GetRecs() []uint64 {
	if m != nil {
		return m.Recs
	}
	return nil
}

func (m *RecParticle) GetTracks() []uint64 {
	if m != nil {
		return m.Tracks
	}
	return nil
}

func (m *RecParticle) GetClusters() []uint64 {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *RecParticle) GetStartVtx() uint64 {
	if m != nil {
		return m.StartVtx
	}
	return 0
}

type Vertex struct {
	Primary int32     `protobuf:"varint,1,opt,name=primary,proto3" json:"primary,omitempty"`
	AlgType int32     `protobuf:"varint,2,opt,name=algType,proto3" json:"algType,omitempty"`
	Chi2    float32   `protobuf:"fixed32,3,opt,name=chi2,proto3" json:"chi2,omitempty"`
	Prob    float32   `protobuf:"fixed32,4,opt,name=prob,proto3" json:"prob,omitempty"`
	Pos     []float32 `protobuf:"fixed32,5,rep,packed,name=pos" json:"pos,omitempty"`
	Cov     []float32 `protobuf:"fixed32,6,rep,packed,name=cov" json:"cov,omitempty"`
	Params  []float32 `protobuf:"fixed32,7,rep,packed,name=params" json:"params,omitempty"`
	RecPart uint64    `protobuf:"varint,8,opt,name=recPart,proto3" json:"recPart,omitempty"`
}

func (m *Vertex) Reset()                    { *m = Vertex{} }
func (m *Vertex) String() string            { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()               {}
func (*Vertex) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{19} }

func (m *Vertex) GetPrimary() int32 {
	if m != nil {
		return m.Primary
	}
	return 0
}

func (m *Vertex) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *Vertex) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Vertex) GetProb() float32 {
	if m != nil {
		return m.Prob
	}
	return 0
}

func (m *Vertex) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Vertex) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Vertex) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Vertex) GetRecPart() uint64 {
	if m != nil {
		return m.RecPart
	}
	return 0
}

type Relation struct {
	From   uint64  `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To     uint64  `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
	Weight float32 `protobuf:"fixed32,3,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *Relation) Reset()                    { *m = Relation{} }
func (m *Relation) String() string            { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()               {}
func (*Relation) Descriptor() ([]byte, []int) { return fileDescriptorLcio, []int{20} }

func (m *Relation) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Relation) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Relation) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func init() {
	proto.RegisterType((*IntParams)(nil), "proio.model.lcio.IntParams")
	proto.RegisterType((*FloatParams)(nil), "proio.model.lcio.FloatParams")
	proto.RegisterType((*StringParams)(nil), "proio.model.lcio.StringParams")
	proto.RegisterType((*Params)(nil), "proio.model.lcio.Params")
	proto.RegisterType((*ParticleID)(nil), "proio.model.lcio.ParticleID")
	proto.RegisterType((*MCParticle)(nil), "proio.model.lcio.MCParticle")
	proto.RegisterType((*SimTrackerHit)(nil), "proio.model.lcio.SimTrackerHit")
	proto.RegisterType((*TrackerRawData)(nil), "proio.model.lcio.TrackerRawData")
	proto.RegisterType((*TrackerData)(nil), "proio.model.lcio.TrackerData")
	proto.RegisterType((*TrackerHit)(nil), "proio.model.lcio.TrackerHit")
	proto.RegisterType((*TrackerPulse)(nil), "proio.model.lcio.TrackerPulse")
	proto.RegisterType((*TrackerHitPlane)(nil), "proio.model.lcio.TrackerHitPlane")
	proto.RegisterType((*TrackerHitZCylinder)(nil), "proio.model.lcio.TrackerHitZCylinder")
	proto.RegisterType((*Track)(nil), "proio.model.lcio.Track")
	proto.RegisterType((*Track_TrackState)(nil), "proio.model.lcio.Track.TrackState")
	proto.RegisterType((*SimCalorimeterHit)(nil), "proio.model.lcio.SimCalorimeterHit")
	proto.RegisterType((*SimCalorimeterHit_Contrib)(nil), "proio.model.lcio.SimCalorimeterHit.Contrib")
	proto.RegisterType((*RawCalorimeterHit)(nil), "proio.model.lcio.RawCalorimeterHit")
	proto.RegisterType((*CalorimeterHit)(nil), "proio.model.lcio.CalorimeterHit")
	proto.RegisterType((*Cluster)(nil), "proio.model.lcio.Cluster")
	proto.RegisterType((*RecParticle)(nil), "proio.model.lcio.RecParticle")
	proto.RegisterType((*Vertex)(nil), "proio.model.lcio.Vertex")
	proto.RegisterType((*Relation)(nil), "proio.model.lcio.Relation")
}
func (m *IntParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		dAtA2 := make([]byte, len(m.Array)*10)
		var j1 int
		for _, num1 := range m.Array {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *FloatParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Array)*4))
		for _, num := range m.Array {
			f3 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f3))
			i += 4
		}
	}
	return i, nil
}

func (m *StringParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		for _, s := range m.Array {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ints) > 0 {
		for k, _ := range m.Ints {
			dAtA[i] = 0xa
			i++
			v := m.Ints[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovLcio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovLcio(uint64(len(k))) + msgSize
			i = encodeVarintLcio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLcio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintLcio(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if len(m.Floats) > 0 {
		for k, _ := range m.Floats {
			dAtA[i] = 0x12
			i++
			v := m.Floats[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovLcio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovLcio(uint64(len(k))) + msgSize
			i = encodeVarintLcio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLcio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintLcio(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.Strings) > 0 {
		for k, _ := range m.Strings {
			dAtA[i] = 0x1a
			i++
			v := m.Strings[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovLcio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovLcio(uint64(len(k))) + msgSize
			i = encodeVarintLcio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLcio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintLcio(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	return i, nil
}

func (m *ParticleID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticleID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Likelihood != 0 {
		dAtA[i] = 0xd
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Likelihood))))
		i += 4
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.PDG != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f7 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f7))
			i += 4
		}
	}
	return i, nil
}

func (m *MCParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parents) > 0 {
		dAtA9 := make([]byte, len(m.Parents)*10)
		var j8 int
		for _, num := range m.Parents {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.Children) > 0 {
		dAtA11 := make([]byte, len(m.Children)*10)
		var j10 int
		for _, num := range m.Children {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.PDG != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Vertex)*8))
		for _, num := range m.Vertex {
			f12 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f12))
			i += 8
		}
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*8))
		for _, num := range m.P {
			f13 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f13))
			i += 8
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x39
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mass))))
		i += 8
	}
	if m.Charge != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.PEndPoint) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.PEndPoint)*8))
		for _, num := range m.PEndPoint {
			f14 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f14))
			i += 8
		}
	}
	if len(m.Spin) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Spin)*4))
		for _, num := range m.Spin {
			f15 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f15))
			i += 4
		}
	}
	if len(m.ColorFlow) > 0 {
		dAtA17 := make([]byte, len(m.ColorFlow)*10)
		var j16 int
		for _, num1 := range m.ColorFlow {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if m.GenStatus != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.SimStatus))
	}
	return i, nil
}

func (m *SimTrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimTrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f18 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f18))
			i += 8
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Mc != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Mc))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f19 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f19))
			i += 4
		}
	}
	if m.PathLength != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PathLength))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *TrackerRawData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerRawData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		dAtA21 := make([]byte, len(m.ADCs)*10)
		var j20 int
		for _, num := range m.ADCs {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	return i, nil
}

func (m *TrackerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.Charges) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Charges)*4))
		for _, num := range m.Charges {
			f22 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f22))
			i += 4
		}
	}
	return i, nil
}

func (m *TrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f23 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f23))
			i += 8
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*8))
		for _, num := range m.Cov {
			f24 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f24))
			i += 8
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		dAtA26 := make([]byte, len(m.RawHits)*10)
		var j25 int
		for _, num := range m.RawHits {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	return i, nil
}

func (m *TrackerPulse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerPulse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Charge != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f27 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f27))
			i += 4
		}
	}
	if m.Quality != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if m.TPC != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.TPC))
	}
	return i, nil
}

func (m *TrackerHitPlane) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitPlane) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f28 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f28))
			i += 8
		}
	}
	if len(m.U) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.U)*4))
		for _, num := range m.U {
			f29 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f29))
			i += 4
		}
	}
	if len(m.V) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.V)*4))
		for _, num := range m.V {
			f30 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f30))
			i += 4
		}
	}
	if m.DU != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DU))))
		i += 4
	}
	if m.DV != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DV))))
		i += 4
	}
	if m.EDep != 0 {
		dAtA[i] = 0x4d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x55
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x5d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		dAtA32 := make([]byte, len(m.RawHits)*10)
		var j31 int
		for _, num := range m.RawHits {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j31))
		i += copy(dAtA[i:], dAtA32[:j31])
	}
	return i, nil
}

func (m *TrackerHitZCylinder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitZCylinder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f33 := math.Float64bits(float64(num))
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f33))
			i += 8
		}
	}
	if len(m.Center) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Center)*4))
		for _, num := range m.Center {
			f34 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f34))
			i += 4
		}
	}
	if m.DRPhi != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DRPhi))))
		i += 4
	}
	if m.DZ != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DZ))))
		i += 4
	}
	if m.EDep != 0 {
		dAtA[i] = 0x45
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x4d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x55
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		dAtA36 := make([]byte, len(m.RawHits)*10)
		var j35 int
		for _, num := range m.RawHits {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	return i, nil
}

func (m *Track) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Chi2))))
		i += 4
	}
	if m.NDF != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.NDF))
	}
	if m.DEdx != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DEdx))))
		i += 4
	}
	if m.DEdxErr != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DEdxErr))))
		i += 4
	}
	if m.Radius != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i += 4
	}
	if len(m.SubDetHits) > 0 {
		dAtA38 := make([]byte, len(m.SubDetHits)*10)
		var j37 int
		for _, num1 := range m.SubDetHits {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	if len(m.States) > 0 {
		for _, msg := range m.States {
			dAtA[i] = 0x42
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hits) > 0 {
		dAtA40 := make([]byte, len(m.Hits)*10)
		var j39 int
		for _, num := range m.Hits {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA40[:j39])
	}
	if len(m.Tracks) > 0 {
		dAtA42 := make([]byte, len(m.Tracks)*10)
		var j41 int
		for _, num := range m.Tracks {
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j41))
		i += copy(dAtA[i:], dAtA42[:j41])
	}
	return i, nil
}

func (m *Track_TrackState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track_TrackState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Loc != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Loc))
	}
	if m.D0 != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.D0))))
		i += 4
	}
	if m.Phi != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Phi))))
		i += 4
	}
	if m.Omega != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Omega))))
		i += 4
	}
	if m.Z0 != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z0))))
		i += 4
	}
	if m.TanL != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TanL))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f43 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f43))
			i += 4
		}
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f44 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f44))
			i += 4
		}
	}
	return i, nil
}

func (m *SimCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f45 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f45))
			i += 4
		}
	}
	if len(m.Contributions) > 0 {
		for _, msg := range m.Contributions {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimCalorimeterHit_Contrib) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit_Contrib) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MCParticle != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.MCParticle))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.PDG != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.StepPos)*4))
		for _, num := range m.StepPos {
			f46 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f46))
			i += 4
		}
	}
	return i, nil
}

func (m *RawCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.TimeStamp))
	}
	return i, nil
}

func (m *CalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f47 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f47))
			i += 4
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Raw != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Raw))
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x15
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyErr))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f48 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f48))
			i += 4
		}
	}
	if len(m.PosErr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.PosErr)*4))
		for _, num := range m.PosErr {
			f49 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f49))
			i += 4
		}
	}
	if m.Theta != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Theta))))
		i += 4
	}
	if m.Phi != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Phi))))
		i += 4
	}
	if len(m.DirErr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.DirErr)*4))
		for _, num := range m.DirErr {
			f50 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f50))
			i += 4
		}
	}
	if len(m.Shape) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Shape)*4))
		for _, num := range m.Shape {
			f51 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f51))
			i += 4
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x52
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Clusters) > 0 {
		dAtA53 := make([]byte, len(m.Clusters)*10)
		var j52 int
		for _, num := range m.Clusters {
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j52))
		i += copy(dAtA[i:], dAtA53[:j52])
	}
	if len(m.Hits) > 0 {
		dAtA55 := make([]byte, len(m.Hits)*10)
		var j54 int
		for _, num := range m.Hits {
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j54))
		i += copy(dAtA[i:], dAtA55[:j54])
	}
	if len(m.Weights) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Weights)*4))
		for _, num := range m.Weights {
			f56 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f56))
			i += 4
		}
	}
	if len(m.SubDetEnes) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.SubDetEnes)*4))
		for _, num := range m.SubDetEnes {
			f57 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f57))
			i += 4
		}
	}
	return i, nil
}

func (m *RecParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f58 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f58))
			i += 4
		}
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f59 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f59))
			i += 4
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x2d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Mass))))
		i += 4
	}
	if m.Charge != 0 {
		dAtA[i] = 0x35
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f60 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f60))
			i += 4
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PIDUsed != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		dAtA[i] = 0x55
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GoodnessOfPID))))
		i += 4
	}
	if len(m.Recs) > 0 {
		dAtA62 := make([]byte, len(m.Recs)*10)
		var j61 int
		for _, num := range m.Recs {
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j61))
		i += copy(dAtA[i:], dAtA62[:j61])
	}
	if len(m.Tracks) > 0 {
		dAtA64 := make([]byte, len(m.Tracks)*10)
		var j63 int
		for _, num := range m.Tracks {
			for num >= 1<<7 {
				dAtA64[j63] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j63++
			}
			dAtA64[j63] = uint8(num)
			j63++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j63))
		i += copy(dAtA[i:], dAtA64[:j63])
	}
	if len(m.Clusters) > 0 {
		dAtA66 := make([]byte, len(m.Clusters)*10)
		var j65 int
		for _, num := range m.Clusters {
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j65))
		i += copy(dAtA[i:], dAtA66[:j65])
	}
	if m.StartVtx != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.StartVtx))
	}
	return i, nil
}

func (m *Vertex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vertex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Primary != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Primary))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Chi2))))
		i += 4
	}
	if m.Prob != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Prob))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f67 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f67))
			i += 4
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f68 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f68))
			i += 4
		}
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f69 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f69))
			i += 4
		}
	}
	if m.RecPart != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.RecPart))
	}
	return i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.From))
	}
	if m.To != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.To))
	}
	if m.Weight != 0 {
		dAtA[i] = 0x1d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	return i, nil
}

func encodeVarintLcio(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IntParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		l = 0
		for _, e := range m.Array {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	return n
}

func (m *FloatParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		n += 1 + sovLcio(uint64(len(m.Array)*4)) + len(m.Array)*4
	}
	return n
}

func (m *StringParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		for _, s := range m.Array {
			l = len(s)
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *Params) Size() (n int) {
	var l int
	_ = l
	if len(m.Ints) > 0 {
		for k, v := range m.Ints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLcio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovLcio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovLcio(uint64(mapEntrySize))
		}
	}
	if len(m.Floats) > 0 {
		for k, v := range m.Floats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLcio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovLcio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovLcio(uint64(mapEntrySize))
		}
	}
	if len(m.Strings) > 0 {
		for k, v := range m.Strings {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLcio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovLcio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovLcio(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ParticleID) Size() (n int) {
	var l int
	_ = l
	if m.Likelihood != 0 {
		n += 5
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if m.AlgType != 0 {
		n += 1 + sovLcio(uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		n += 1 + sovLcio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	return n
}

func (m *MCParticle) Size() (n int) {
	var l int
	_ = l
	if len(m.Parents) > 0 {
		l = 0
		for _, e := range m.Parents {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		n += 1 + sovLcio(uint64(len(m.Vertex)*8)) + len(m.Vertex)*8
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*8)) + len(m.P)*8
	}
	if m.Mass != 0 {
		n += 9
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.PEndPoint) > 0 {
		n += 1 + sovLcio(uint64(len(m.PEndPoint)*8)) + len(m.PEndPoint)*8
	}
	if len(m.Spin) > 0 {
		n += 1 + sovLcio(uint64(len(m.Spin)*4)) + len(m.Spin)*4
	}
	if len(m.ColorFlow) > 0 {
		l = 0
		for _, e := range m.ColorFlow {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.GenStatus != 0 {
		n += 1 + sovLcio(uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		n += 1 + sovLcio(uint64(m.SimStatus))
	}
	return n
}

func (m *SimTrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Mc != 0 {
		n += 1 + sovLcio(uint64(m.Mc))
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.PathLength != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	return n
}

func (m *TrackerRawData) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 1 + sovLcio(uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		l = 0
		for _, e := range m.ADCs {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	return n
}

func (m *TrackerData) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Charges) > 0 {
		n += 1 + sovLcio(uint64(len(m.Charges)*4)) + len(m.Charges)*4
	}
	return n
}

func (m *TrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*8)) + len(m.Cov)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		l = 0
		for _, e := range m.RawHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	return n
}

func (m *TrackerPulse) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if m.TPC != 0 {
		n += 1 + sovLcio(uint64(m.TPC))
	}
	return n
}

func (m *TrackerHitPlane) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.U) > 0 {
		n += 1 + sovLcio(uint64(len(m.U)*4)) + len(m.U)*4
	}
	if len(m.V) > 0 {
		n += 1 + sovLcio(uint64(len(m.V)*4)) + len(m.V)*4
	}
	if m.DU != 0 {
		n += 5
	}
	if m.DV != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		l = 0
		for _, e := range m.RawHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	return n
}

func (m *TrackerHitZCylinder) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Center) > 0 {
		n += 1 + sovLcio(uint64(len(m.Center)*4)) + len(m.Center)*4
	}
	if m.DRPhi != 0 {
		n += 5
	}
	if m.DZ != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		l = 0
		for _, e := range m.RawHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	return n
}

func (m *Track) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.NDF != 0 {
		n += 1 + sovLcio(uint64(m.NDF))
	}
	if m.DEdx != 0 {
		n += 5
	}
	if m.DEdxErr != 0 {
		n += 5
	}
	if m.Radius != 0 {
		n += 5
	}
	if len(m.SubDetHits) > 0 {
		l = 0
		for _, e := range m.SubDetHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Hits) > 0 {
		l = 0
		for _, e := range m.Hits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Tracks) > 0 {
		l = 0
		for _, e := range m.Tracks {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	return n
}

func (m *Track_TrackState) Size() (n int) {
	var l int
	_ = l
	if m.Loc != 0 {
		n += 1 + sovLcio(uint64(m.Loc))
	}
	if m.D0 != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if m.Omega != 0 {
		n += 5
	}
	if m.Z0 != 0 {
		n += 5
	}
	if m.TanL != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Ref) > 0 {
		n += 1 + sovLcio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	return n
}

func (m *SimCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Contributions) > 0 {
		for _, e := range m.Contributions {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	return n
}

func (m *SimCalorimeterHit_Contrib) Size() (n int) {
	var l int
	_ = l
	if m.MCParticle != 0 {
		n += 1 + sovLcio(uint64(m.MCParticle))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		n += 1 + sovLcio(uint64(len(m.StepPos)*4)) + len(m.StepPos)*4
	}
	return n
}

func (m *RawCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		n += 1 + sovLcio(uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovLcio(uint64(m.TimeStamp))
	}
	return n
}

func (m *CalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Raw != 0 {
		n += 1 + sovLcio(uint64(m.Raw))
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.PosErr) > 0 {
		n += 1 + sovLcio(uint64(len(m.PosErr)*4)) + len(m.PosErr)*4
	}
	if m.Theta != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if len(m.DirErr) > 0 {
		n += 1 + sovLcio(uint64(len(m.DirErr)*4)) + len(m.DirErr)*4
	}
	if len(m.Shape) > 0 {
		n += 1 + sovLcio(uint64(len(m.Shape)*4)) + len(m.Shape)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Clusters) > 0 {
		l = 0
		for _, e := range m.Clusters {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Hits) > 0 {
		l = 0
		for _, e := range m.Hits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Weights) > 0 {
		n += 1 + sovLcio(uint64(len(m.Weights)*4)) + len(m.Weights)*4
	}
	if len(m.SubDetEnes) > 0 {
		n += 1 + sovLcio(uint64(len(m.SubDetEnes)*4)) + len(m.SubDetEnes)*4
	}
	return n
}

func (m *RecParticle) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Mass != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Ref) > 0 {
		n += 1 + sovLcio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if m.PIDUsed != 0 {
		n += 1 + sovLcio(uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		n += 5
	}
	if len(m.Recs) > 0 {
		l = 0
		for _, e := range m.Recs {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Tracks) > 0 {
		l = 0
		for _, e := range m.Tracks {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Clusters) > 0 {
		l = 0
		for _, e := range m.Clusters {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.StartVtx != 0 {
		n += 1 + sovLcio(uint64(m.StartVtx))
	}
	return n
}

func (m *Vertex) Size() (n int) {
	var l int
	_ = l
	if m.Primary != 0 {
		n += 1 + sovLcio(uint64(m.Primary))
	}
	if m.AlgType != 0 {
		n += 1 + sovLcio(uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.Prob != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Params) > 0 {
		n += 1 + sovLcio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	if m.RecPart != 0 {
		n += 1 + sovLcio(uint64(m.RecPart))
	}
	return n
}

func (m *Relation) Size() (n int) {
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovLcio(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovLcio(uint64(m.To))
	}
	if m.Weight != 0 {
		n += 5
	}
	return n
}

func sovLcio(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLcio(x uint64) (n int) {
	return sovLcio(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IntParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Array = append(m.Array, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Array = append(m.Array, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Array = append(m.Array, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Array = append(m.Array, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Array = append(m.Array, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ints == nil {
				m.Ints = make(map[string]*IntParams)
			}
			var mapkey string
			var mapvalue *IntParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLcio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &IntParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLcio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLcio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ints[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Floats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Floats == nil {
				m.Floats = make(map[string]*FloatParams)
			}
			var mapkey string
			var mapvalue *FloatParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLcio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FloatParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLcio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLcio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Floats[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = make(map[string]*StringParams)
			}
			var mapkey string
			var mapvalue *StringParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLcio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StringParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLcio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLcio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Strings[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticleID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticleID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticleID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Likelihood", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Likelihood = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parents = append(m.Parents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parents = append(m.Parents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Vertex = append(m.Vertex, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Vertex = append(m.Vertex, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mass = float64(math.Float64frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 9:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PEndPoint = append(m.PEndPoint, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PEndPoint = append(m.PEndPoint, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PEndPoint", wireType)
			}
		case 10:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Spin = append(m.Spin, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Spin = append(m.Spin, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spin", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColorFlow = append(m.ColorFlow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColorFlow = append(m.ColorFlow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorFlow", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenStatus", wireType)
			}
			m.GenStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimStatus", wireType)
			}
			m.SimStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SimStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimTrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimTrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimTrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mc", wireType)
			}
			m.Mc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mc |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathLength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PathLength = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerRawData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerRawData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerRawData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ADCs = append(m.ADCs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ADCs = append(m.ADCs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ADCs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Charges = append(m.Charges, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Charges = append(m.Charges, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charges", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawHits = append(m.RawHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawHits = append(m.RawHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerPulse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerPulse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerPulse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TPC", wireType)
			}
			m.TPC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TPC |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitPlane) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitPlane: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitPlane: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.U = append(m.U, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.U = append(m.U, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.V = append(m.V, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.V = append(m.V, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DU = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DV", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DV = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawHits = append(m.RawHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawHits = append(m.RawHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitZCylinder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitZCylinder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitZCylinder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Center = append(m.Center, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Center = append(m.Center, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Center", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DRPhi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DRPhi = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DZ = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawHits = append(m.RawHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawHits = append(m.RawHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Track: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Track: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Chi2 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NDF", wireType)
			}
			m.NDF = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NDF |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DEdx = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdxErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DEdxErr = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SubDetHits = append(m.SubDetHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SubDetHits = append(m.SubDetHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetHits", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, &Track_TrackState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Hits = append(m.Hits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Hits = append(m.Hits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tracks = append(m.Tracks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tracks = append(m.Tracks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track_TrackState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			m.Loc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field D0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.D0 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Phi = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Omega", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Omega = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z0 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TanL", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TanL = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contributions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contributions = append(m.Contributions, &SimCalorimeterHit_Contrib{})
			if err := m.Contributions[len(m.Contributions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit_Contrib) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contrib: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contrib: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MCParticle", wireType)
			}
			m.MCParticle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MCParticle |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.StepPos = append(m.StepPos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.StepPos = append(m.StepPos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StepPos", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amplitude", wireType)
			}
			m.Amplitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amplitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyErr = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			m.Raw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Raw |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyErr = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.PosErr = append(m.PosErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.PosErr = append(m.PosErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PosErr", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Theta", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Theta = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Phi = float32(math.Float32frombits(v))
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.DirErr = append(m.DirErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.DirErr = append(m.DirErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DirErr", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Shape = append(m.Shape, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Shape = append(m.Shape, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Clusters = append(m.Clusters, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Clusters = append(m.Clusters, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Hits = append(m.Hits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Hits = append(m.Hits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
		case 13:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Weights = append(m.Weights, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Weights = append(m.Weights, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
		case 14:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.SubDetEnes = append(m.SubDetEnes, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.SubDetEnes = append(m.SubDetEnes, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetEnes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Mass = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDUsed", wireType)
			}
			m.PIDUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PIDUsed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodnessOfPID", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GoodnessOfPID = float32(math.Float32frombits(v))
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Recs = append(m.Recs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Recs = append(m.Recs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Recs", wireType)
			}
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tracks = append(m.Tracks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tracks = append(m.Tracks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
		case 13:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Clusters = append(m.Clusters, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Clusters = append(m.Clusters, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVtx", wireType)
			}
			m.StartVtx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVtx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vertex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vertex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vertex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			m.Primary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Primary |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Chi2 = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prob", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Prob = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecPart", wireType)
			}
			m.RecPart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecPart |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLcio(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLcio
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLcio(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLcio = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLcio   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proio/model/lcio.proto", fileDescriptorLcio) }

var fileDescriptorLcio = []byte{
	// 1664 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4f, 0x6f, 0xe4, 0x48,
	0x15, 0xc7, 0x6e, 0x77, 0x77, 0xfa, 0x75, 0x27, 0x64, 0x0d, 0x8a, 0xac, 0x30, 0x44, 0xc1, 0x0c,
	0x52, 0x24, 0x44, 0x26, 0x9b, 0x45, 0x08, 0xad, 0x90, 0x10, 0x9b, 0x4e, 0xd8, 0x48, 0xc3, 0xd2,
	0x54, 0x26, 0x01, 0xe5, 0x56, 0xb1, 0x6b, 0xba, 0xad, 0x71, 0xbb, 0x4c, 0xb9, 0x7a, 0x32, 0xd9,
	0x1b, 0x82, 0x0f, 0xc1, 0x05, 0x2e, 0x5c, 0x39, 0x70, 0xe6, 0x03, 0xac, 0x56, 0xe2, 0xc2, 0x85,
	0x3b, 0x1a, 0xce, 0xc0, 0x57, 0x40, 0xef, 0x55, 0x55, 0xdb, 0xce, 0x38, 0x08, 0x2d, 0x33, 0x97,
	0xe4, 0xbd, 0x57, 0x7f, 0xfc, 0xde, 0xef, 0xf7, 0xde, 0xab, 0xaa, 0x86, 0x9d, 0x52, 0xc9, 0x4c,
	0x3e, 0x59, 0xca, 0x54, 0xe4, 0x4f, 0xf2, 0x24, 0x93, 0x87, 0xa5, 0x92, 0x5a, 0x86, 0xdb, 0x64,
	0x3f, 0x24, 0xfb, 0x21, 0xda, 0xe3, 0x6f, 0xc0, 0xe8, 0xbc, 0xd0, 0x33, 0xae, 0xf8, 0xb2, 0x0a,
	0xbf, 0x0a, 0x7d, 0xae, 0x14, 0xbf, 0x8b, 0xbc, 0xfd, 0xde, 0x41, 0x9f, 0x19, 0x25, 0xfe, 0x26,
	0x8c, 0xcf, 0x72, 0xc9, 0x3b, 0x27, 0xf9, 0x6e, 0xd2, 0x63, 0x98, 0x5c, 0x68, 0x95, 0x15, 0xf3,
	0xae, 0x59, 0x23, 0x37, 0xeb, 0x2f, 0x3d, 0x18, 0xd8, 0x09, 0xdf, 0x83, 0x20, 0x2b, 0x74, 0x45,
	0xe3, 0xe3, 0xe3, 0xf8, 0xf0, 0xbe, 0x67, 0x87, 0x66, 0xde, 0xe1, 0x79, 0xa1, 0xab, 0xd3, 0x42,
	0xab, 0x3b, 0x46, 0xf3, 0xc3, 0x1f, 0xc0, 0xe0, 0x39, 0x7a, 0x53, 0x45, 0x3e, 0xad, 0x7c, 0xfc,
	0xe0, 0x4a, 0x72, 0xda, 0xae, 0xb5, 0x6b, 0xc2, 0x1f, 0xc2, 0xb0, 0x22, 0x37, 0xab, 0xa8, 0x47,
	0xcb, 0xbf, 0xf5, 0xe0, 0x72, 0x13, 0x8e, 0x5d, 0xef, 0x56, 0xed, 0x3e, 0x23, 0xbc, 0x8c, 0x35,
	0xdc, 0x86, 0xde, 0x0b, 0x81, 0x21, 0x7a, 0x07, 0x23, 0x86, 0x62, 0xf8, 0x3e, 0xf4, 0x5f, 0xf2,
	0x7c, 0x25, 0x22, 0x7f, 0xdf, 0x3b, 0x18, 0x1f, 0x7f, 0xed, 0xcd, 0xdd, 0xd7, 0x68, 0x33, 0x33,
	0xf3, 0x43, 0xff, 0xfb, 0xde, 0xee, 0x2f, 0x2c, 0xc4, 0x0f, 0xee, 0xfb, 0x41, 0x7b, 0xdf, 0xaf,
	0xbf, 0xb9, 0x6f, 0x83, 0xa2, 0xe6, 0xce, 0xd7, 0x8e, 0x97, 0x07, 0xb7, 0xfe, 0x6e, 0x7b, 0xeb,
	0xbd, 0x37, 0xb7, 0x6e, 0x12, 0xdb, 0xd8, 0x3b, 0xfe, 0x8d, 0x07, 0x30, 0xe3, 0x4a, 0x67, 0x49,
	0x2e, 0xce, 0xa7, 0xe1, 0x1e, 0x40, 0x9e, 0xbd, 0x10, 0x79, 0xb6, 0x90, 0x32, 0xa5, 0x2f, 0xf8,
	0xac, 0x61, 0x09, 0x43, 0x08, 0xf4, 0x5d, 0x69, 0xbe, 0xd3, 0x67, 0x24, 0xa3, 0x3b, 0xb3, 0xe9,
	0x8f, 0xa3, 0x1e, 0x99, 0x50, 0x0c, 0x23, 0x18, 0xf2, 0x7c, 0xfe, 0x0c, 0x27, 0x06, 0x64, 0x75,
	0x6a, 0xb8, 0x03, 0x83, 0x92, 0x7c, 0x88, 0xfa, 0x94, 0x79, 0x56, 0x8b, 0x3f, 0xf3, 0x01, 0x7e,
	0x72, 0xe2, 0x1c, 0xc1, 0x0d, 0x4a, 0xae, 0x84, 0xcb, 0xad, 0x80, 0x39, 0x35, 0xdc, 0x85, 0x8d,
	0x64, 0x91, 0xe5, 0xa9, 0x12, 0x05, 0x25, 0x4f, 0xc0, 0xd6, 0x7a, 0x87, 0x23, 0x3b, 0x30, 0x78,
	0x29, 0x94, 0x16, 0xaf, 0xa2, 0x60, 0xbf, 0x77, 0xe0, 0x31, 0xab, 0x51, 0x18, 0xd9, 0x52, 0x44,
	0x7d, 0x0a, 0x90, 0xe4, 0x70, 0x02, 0x5e, 0x19, 0x0d, 0x68, 0x9a, 0x57, 0xe2, 0x8c, 0x25, 0xaf,
	0xaa, 0x68, 0xb8, 0xef, 0x1d, 0x78, 0x8c, 0x64, 0xdc, 0x2d, 0x59, 0x70, 0x35, 0x17, 0xd1, 0x06,
	0xad, 0xb3, 0x5a, 0xf8, 0x08, 0x46, 0xb3, 0xd3, 0x22, 0x9d, 0xc9, 0xac, 0xd0, 0xd1, 0x88, 0x76,
	0xa8, 0x0d, 0xb8, 0x53, 0x55, 0x66, 0x45, 0x04, 0x14, 0x30, 0xc9, 0xb8, 0x22, 0x91, 0xb9, 0x54,
	0x67, 0xb9, 0xbc, 0x8d, 0xc6, 0x54, 0xa8, 0xb5, 0x01, 0x47, 0xe7, 0xa2, 0xb8, 0xd0, 0x5c, 0xaf,
	0xaa, 0x68, 0x42, 0xd1, 0xd4, 0x06, 0x1c, 0xad, 0xb2, 0xa5, 0x1d, 0xdd, 0xdc, 0xf7, 0x0e, 0x36,
	0x59, 0x6d, 0x88, 0xff, 0xe6, 0xc1, 0xe6, 0x45, 0xb6, 0x7c, 0xa6, 0x78, 0xf2, 0x42, 0xa8, 0x8f,
	0x33, 0x8d, 0x58, 0x26, 0x22, 0xcf, 0xcf, 0xa7, 0x47, 0xc4, 0x67, 0x9f, 0x39, 0xb5, 0x1e, 0x79,
	0xdf, 0xf2, 0xe9, 0x54, 0x44, 0xb2, 0x94, 0xa6, 0xbc, 0x3c, 0x86, 0x22, 0x46, 0x71, 0x3a, 0x15,
	0x25, 0xf1, 0xe9, 0x33, 0x92, 0x3b, 0x51, 0xdc, 0x02, 0x7f, 0x99, 0x44, 0x83, 0x7d, 0xef, 0x20,
	0x60, 0xfe, 0x32, 0x31, 0xa8, 0x0e, 0x29, 0x74, 0xaf, 0xc4, 0xf4, 0x2a, 0xb9, 0x5e, 0x3c, 0x15,
	0xc5, 0x5c, 0x2f, 0x2c, 0x8a, 0x0d, 0x0b, 0x7a, 0xf4, 0xcb, 0x15, 0xcf, 0x33, 0x7d, 0x17, 0x8d,
	0x8c, 0x47, 0x56, 0x8d, 0x73, 0xd8, 0xb2, 0x31, 0x31, 0x7e, 0x3b, 0xe5, 0x9a, 0x7f, 0xa1, 0xb8,
	0x9c, 0xc7, 0x3d, 0x9b, 0xbe, 0xe8, 0x71, 0x08, 0xc1, 0x8f, 0xa6, 0x27, 0x15, 0x65, 0xc8, 0x26,
	0x23, 0x39, 0x96, 0x30, 0xb6, 0x5f, 0x7b, 0x2b, 0x9f, 0x72, 0xe0, 0xe0, 0x6c, 0x4a, 0x19, 0xf3,
	0x35, 0x9f, 0x39, 0x35, 0xfe, 0x97, 0x07, 0xf0, 0x7f, 0x72, 0xe6, 0x4a, 0xb3, 0xd7, 0x2e, 0x4d,
	0xe4, 0x31, 0xa8, 0x79, 0xdc, 0x86, 0x5e, 0x22, 0x5f, 0x52, 0xf5, 0x79, 0x0c, 0xc5, 0x35, 0xb3,
	0x83, 0x06, 0xb3, 0x11, 0x0c, 0xf1, 0xff, 0xa9, 0x52, 0x54, 0x00, 0x3e, 0x73, 0xea, 0x3a, 0xac,
	0x8d, 0x76, 0x58, 0xdd, 0xac, 0xe1, 0x88, 0xe2, 0xb7, 0x1f, 0x67, 0xba, 0xa2, 0xf4, 0x0f, 0x98,
	0x53, 0xe3, 0x3f, 0x7a, 0x30, 0xb1, 0x01, 0xcf, 0x56, 0x79, 0x25, 0xde, 0x1a, 0xc6, 0x75, 0x91,
	0x06, 0xad, 0x22, 0x6d, 0x04, 0xee, 0x9b, 0xc0, 0x1b, 0x6e, 0x0f, 0xda, 0x6e, 0x6f, 0x43, 0xef,
	0xd9, 0xec, 0x84, 0x42, 0x0f, 0x18, 0x8a, 0xf1, 0xef, 0x7c, 0xf8, 0x72, 0xcd, 0xcf, 0x2c, 0xe7,
	0x85, 0x78, 0x87, 0x24, 0x4d, 0xc0, 0xbb, 0xb4, 0x9e, 0x7a, 0x97, 0xa8, 0x5d, 0x51, 0x63, 0xf2,
	0x99, 0x77, 0x85, 0x05, 0x96, 0x5e, 0x5a, 0x56, 0xfc, 0xf4, 0x92, 0xf4, 0x2b, 0x4b, 0x87, 0x9f,
	0x5e, 0xad, 0xe9, 0x1c, 0x75, 0xd3, 0x09, 0xdd, 0x74, 0x8e, 0xbb, 0xe9, 0x9c, 0x3c, 0x48, 0xe7,
	0x66, 0x9b, 0xce, 0x3f, 0xf8, 0xf0, 0x95, 0x1a, 0x9f, 0xeb, 0x93, 0xbb, 0x3c, 0x2b, 0x52, 0xa1,
	0xde, 0x21, 0x46, 0xc8, 0xb3, 0x28, 0xb4, 0x50, 0xee, 0x24, 0x31, 0x1a, 0x5e, 0x5a, 0x52, 0x36,
	0x5b, 0x64, 0x36, 0x9f, 0x8d, 0x42, 0x28, 0x5d, 0xaf, 0x51, 0xbb, 0x5e, 0xa3, 0xb4, 0xd1, 0x8d,
	0xd2, 0xa8, 0x1b, 0x25, 0xe8, 0x46, 0x69, 0xfc, 0x20, 0x4a, 0x93, 0x36, 0x4a, 0x7f, 0xea, 0x41,
	0x9f, 0x50, 0x5a, 0xc7, 0xe8, 0x35, 0x62, 0x0c, 0x21, 0x48, 0x16, 0xd9, 0x31, 0xc1, 0xe1, 0x33,
	0x92, 0x31, 0xee, 0x4f, 0xa6, 0x67, 0xee, 0x48, 0xfb, 0x64, 0x7a, 0x86, 0xb3, 0xd2, 0xd3, 0xf4,
	0x95, 0x6b, 0xc4, 0x28, 0xe3, 0x17, 0xf1, 0x3f, 0x7a, 0x6e, 0x7a, 0xb1, 0x53, 0x11, 0x25, 0xc5,
	0xd3, 0x6c, 0x55, 0x59, 0x38, 0xac, 0x86, 0x8d, 0xb8, 0x5a, 0xdd, 0x4c, 0x85, 0x26, 0x37, 0x87,
	0x74, 0x02, 0x35, 0x2c, 0xe1, 0x87, 0x30, 0xa8, 0x34, 0xd7, 0xa2, 0x8a, 0x36, 0x1e, 0xba, 0xdb,
	0x51, 0x20, 0xe6, 0x2f, 0x9e, 0x3d, 0x82, 0xd9, 0x15, 0xe8, 0xe1, 0x02, 0x77, 0x1d, 0x51, 0xf0,
	0x24, 0xa3, 0x1f, 0x1a, 0x67, 0xba, 0x3e, 0x60, 0xb5, 0xdd, 0xdf, 0xbb, 0xbe, 0x47, 0x5b, 0x60,
	0xb8, 0xb9, 0x4c, 0x2c, 0x2a, 0x28, 0x12, 0x71, 0x47, 0x16, 0x12, 0x3f, 0x3d, 0xa2, 0x44, 0x58,
	0x64, 0xb6, 0xe2, 0x51, 0x44, 0xc2, 0xe5, 0x52, 0xcc, 0xb9, 0x45, 0xc4, 0x28, 0xb8, 0xee, 0xd3,
	0x23, 0x8b, 0x86, 0xff, 0xe9, 0x11, 0x01, 0xce, 0x8b, 0xa7, 0xae, 0xcb, 0xa1, 0xec, 0x5a, 0xc2,
	0xb0, 0x6e, 0x09, 0xdb, 0xd0, 0x53, 0xe2, 0x39, 0xc5, 0xec, 0x33, 0x14, 0xe3, 0xcf, 0x7d, 0x78,
	0xef, 0x22, 0x5b, 0x9e, 0xf0, 0x5c, 0xaa, 0x6c, 0x29, 0xf4, 0x17, 0xef, 0xcf, 0x3b, 0x30, 0x10,
	0x85, 0x50, 0xf3, 0x3b, 0xeb, 0xbc, 0xd5, 0x9a, 0xa9, 0xed, 0x9b, 0xd4, 0xfe, 0x19, 0x6c, 0x26,
	0xb2, 0xd0, 0x2a, 0xbb, 0x59, 0xe9, 0x4c, 0x16, 0xe6, 0xae, 0x34, 0x3e, 0xfe, 0x76, 0xc7, 0xad,
	0xee, 0xbe, 0x67, 0x87, 0x27, 0x66, 0x21, 0x6b, 0xef, 0xb0, 0xfb, 0x2b, 0x0f, 0x86, 0x76, 0x08,
	0xb9, 0xaf, 0xaf, 0x5a, 0xe4, 0x7f, 0xc0, 0x9a, 0x97, 0xaf, 0xda, 0x51, 0xbf, 0xe5, 0x68, 0x57,
	0xb7, 0xb5, 0x57, 0xae, 0xa0, 0x75, 0xf7, 0xab, 0xb4, 0x28, 0x67, 0xd2, 0x5d, 0xf1, 0x9c, 0x1a,
	0xff, 0xda, 0x83, 0xf7, 0x18, 0xbf, 0x7d, 0x0b, 0x50, 0x3e, 0x82, 0x11, 0x5f, 0x96, 0x79, 0xa6,
	0x57, 0xa9, 0x6b, 0x13, 0xb5, 0x01, 0x47, 0xd1, 0xb7, 0x0b, 0xcd, 0x97, 0xa5, 0xf5, 0xac, 0x36,
	0xc4, 0x9f, 0x79, 0xb0, 0xf5, 0x0e, 0xd9, 0x7c, 0x04, 0x23, 0x23, 0x61, 0x31, 0x9a, 0x8c, 0xac,
	0x0d, 0x9d, 0x37, 0x26, 0xcb, 0xff, 0xa0, 0xe6, 0xdf, 0x35, 0x87, 0x61, 0xbb, 0x01, 0x2a, 0x7e,
	0x4b, 0xfd, 0x2a, 0x60, 0x28, 0xc6, 0xff, 0xf6, 0x61, 0x78, 0x92, 0xaf, 0x2a, 0x6c, 0x7a, 0x5d,
	0xed, 0xe4, 0x21, 0x1a, 0x5b, 0x1e, 0xf6, 0xee, 0x7b, 0xf8, 0x66, 0x36, 0xe2, 0x95, 0x5d, 0x56,
	0xa6, 0xb7, 0x98, 0x2b, 0x3b, 0x69, 0x58, 0x77, 0x7a, 0x21, 0x34, 0x77, 0x8d, 0x96, 0x14, 0x57,
	0x9f, 0xc3, 0xba, 0x3e, 0x77, 0x60, 0x90, 0x66, 0x0a, 0xd7, 0x9b, 0xb2, 0xb2, 0x1a, 0xae, 0xaf,
	0x16, 0xbc, 0x14, 0xd4, 0x27, 0x7c, 0x66, 0x94, 0xf0, 0x08, 0x82, 0xd9, 0xf9, 0xd4, 0xb4, 0x89,
	0xf1, 0xf1, 0xa3, 0xce, 0x97, 0x9d, 0x7d, 0xac, 0x30, 0x9a, 0x49, 0x2f, 0x02, 0x03, 0x43, 0x45,
	0x57, 0x69, 0x7c, 0x11, 0x58, 0x7d, 0xdd, 0x8a, 0x26, 0x8d, 0x56, 0x14, 0xc1, 0xf0, 0x56, 0x64,
	0xf3, 0x85, 0x3d, 0xc4, 0x7c, 0xe6, 0xd4, 0xba, 0x29, 0x9e, 0x16, 0xa2, 0x8a, 0xb6, 0x68, 0xb0,
	0x61, 0x89, 0xff, 0xe9, 0xc3, 0x98, 0x89, 0x64, 0x5d, 0x28, 0x5d, 0xa8, 0xd3, 0x7d, 0xd7, 0x77,
	0xf7, 0xdd, 0xff, 0x52, 0xf3, 0xd8, 0x79, 0x82, 0xba, 0xf3, 0xb8, 0xf7, 0x86, 0xcd, 0x8c, 0x7b,
	0xef, 0x8d, 0xc1, 0xfd, 0xab, 0x0c, 0x76, 0xa9, 0xe1, 0xba, 0x4b, 0xad, 0x51, 0xdb, 0xf8, 0x9f,
	0x51, 0x8b, 0x60, 0x38, 0x3b, 0x9f, 0x5e, 0x56, 0x22, 0x75, 0x77, 0x36, 0xab, 0x86, 0x8f, 0x61,
	0x73, 0x2e, 0x65, 0x5a, 0x88, 0xaa, 0xfa, 0xe9, 0xf3, 0xd9, 0xf9, 0xd4, 0x9e, 0x7a, 0x6d, 0x23,
	0xfa, 0xab, 0x44, 0xe2, 0x10, 0x27, 0xb9, 0xd1, 0xe4, 0x27, 0xcd, 0x26, 0xdf, 0x62, 0x68, 0xf3,
	0x1e, 0x43, 0xbb, 0xb0, 0x51, 0x69, 0xae, 0xf4, 0x95, 0x7e, 0x15, 0x6d, 0x51, 0x72, 0xaf, 0xf5,
	0xf8, 0xcf, 0x1e, 0x0c, 0xae, 0xcc, 0x83, 0x0d, 0x1f, 0x84, 0x2a, 0x5b, 0x72, 0x75, 0xe7, 0x4a,
	0xd4, 0xaa, 0xcd, 0xb7, 0xa6, 0xdf, 0x7e, 0x6b, 0xba, 0xf3, 0xb4, 0xd7, 0x38, 0x4f, 0x43, 0x08,
	0x4a, 0x25, 0x6f, 0xdc, 0xe9, 0x89, 0xb2, 0x4b, 0xf9, 0x7e, 0x9d, 0xf2, 0x96, 0x9e, 0x41, 0x4d,
	0x4f, 0xfd, 0x6e, 0x1d, 0x36, 0xdf, 0xad, 0x74, 0xd6, 0x9b, 0x8c, 0xb0, 0xa5, 0xe9, 0xd4, 0xf8,
	0x0c, 0x36, 0x98, 0xc8, 0x39, 0xb6, 0x5f, 0xfc, 0xea, 0x73, 0x25, 0x97, 0xb6, 0xd7, 0x92, 0x8c,
	0x07, 0x94, 0x96, 0xe4, 0x72, 0xc0, 0x7c, 0x2d, 0xf1, 0x0b, 0x26, 0x0f, 0x5d, 0xaa, 0x18, 0xed,
	0xa3, 0x9f, 0x7f, 0xfe, 0x7a, 0xcf, 0xfb, 0xeb, 0xeb, 0x3d, 0xef, 0xef, 0xaf, 0xf7, 0xbc, 0xdf,
	0xfe, 0x63, 0xef, 0x4b, 0x30, 0x6e, 0xb0, 0xfb, 0x51, 0xf0, 0x34, 0xc9, 0xe4, 0xf5, 0xf1, 0x3c,
	0xd3, 0x8b, 0xd5, 0xcd, 0x61, 0x22, 0x97, 0x4f, 0x52, 0x91, 0x64, 0x37, 0x22, 0x4f, 0xa4, 0x2c,
	0x85, 0x7a, 0x62, 0x7e, 0x44, 0x9a, 0xcb, 0xef, 0xdc, 0xff, 0x35, 0xe9, 0x66, 0x40, 0x3f, 0x27,
	0x7d, 0xf0, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x82, 0x70, 0xbc, 0xb7, 0x68, 0x12, 0x00, 0x00,
}
